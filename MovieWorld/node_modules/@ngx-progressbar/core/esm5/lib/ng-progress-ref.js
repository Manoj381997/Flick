/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Subject, BehaviorSubject, timer, of, combineLatest } from 'rxjs';
import { tap, map, skip, delay, filter, debounce, switchMap, distinctUntilChanged } from 'rxjs/operators';
var NgProgressRef = /** @class */ (function () {
    function NgProgressRef(customConfig) {
        var _this = this;
        this._state = { active: false, value: 0 };
        /**
         * Stream that increments and updates progress state
         */
        this._trickling$ = new Subject();
        /**
         * Stream that emits when progress state is changed
         */
        this.state$ = new BehaviorSubject(this._state);
        /**
         * Stream that emits when config is changed
         */
        this.config$ = new Subject();
        combineLatest(this._trickling$, this.config$).pipe(debounce(function (_a) {
            var _b = tslib_1.__read(_a, 2), start = _b[0], config = _b[1];
            return timer(start ? _this._config.debounceTime : 0);
        }), switchMap(function (_a) {
            var _b = tslib_1.__read(_a, 2), start = _b[0], config = _b[1];
            return start ? _this._trickling(config) : _this._complete(config);
        })).subscribe();
        this.setConfig(customConfig);
    }
    Object.defineProperty(NgProgressRef.prototype, "isStarted", {
        get: /**
         * @return {?}
         */
        function () {
            return this._state.active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "started", {
        /** Progress start event */
        get: /**
         * Progress start event
         * @return {?}
         */
        function () {
            return this.state$.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return active; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "completed", {
        /** Progress ended event */
        get: /**
         * Progress ended event
         * @return {?}
         */
        function () {
            return this.state$.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return !active; }), skip(1));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgProgressRef.prototype.start = /**
     * @return {?}
     */
    function () {
        this._trickling$.next(true);
    };
    /**
     * @return {?}
     */
    NgProgressRef.prototype.complete = /**
     * @return {?}
     */
    function () {
        this._trickling$.next(false);
    };
    /**
     * @param {?=} amount
     * @return {?}
     */
    NgProgressRef.prototype.inc = /**
     * @param {?=} amount
     * @return {?}
     */
    function (amount) {
        var /** @type {?} */ n = this._state.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.trickleFunc(n);
            }
            this.set(n + amount);
        }
    };
    /**
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.set = /**
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this._setState({ value: this._clamp(n), active: true });
    };
    /**
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.setConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this._config = tslib_1.__assign({}, this._config, config);
        this.config$.next(this._config);
    };
    /**
     * Meant to be used internally and not by user directly
     * Users should use NgProgressManager.destroy(id) instead
     */
    /**
     * Meant to be used internally and not by user directly
     * Users should use NgProgressManager.destroy(id) instead
     * @return {?}
     */
    NgProgressRef.prototype.destroy = /**
     * Meant to be used internally and not by user directly
     * Users should use NgProgressManager.destroy(id) instead
     * @return {?}
     */
    function () {
        this._trickling$.complete();
        this.state$.complete();
        this.config$.complete();
    };
    /**
     * @param {?} state
     * @return {?}
     */
    NgProgressRef.prototype._setState = /**
     * @param {?} state
     * @return {?}
     */
    function (state) {
        this._state = tslib_1.__assign({}, this._state, state);
        this.state$.next(this._state);
    };
    /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype._clamp = /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    function (n) {
        return Math.max(this._config.min, Math.min(this._config.max, n));
    };
    /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype._trickling = /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        if (!this.isStarted) {
            this.set(this._config.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(function () { return _this.inc(); }));
    };
    /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype._complete = /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        return !this.isStarted ? of({}) : of({}).pipe(
        // Completes the progress
        tap(function () { return _this._setState({ value: 100 }); }), 
        // Hides the progress bar after a tiny delay
        delay(config.speed * 1.7), tap(function () { return _this._setState({ active: false }); }), 
        // Resets the progress state
        delay(config.speed), tap(function () { return _this._setState({ value: 0 }); }));
    };
    return NgProgressRef;
}());
export { NgProgressRef };
function NgProgressRef_tsickle_Closure_declarations() {
    /** @type {?} */
    NgProgressRef.prototype._state;
    /** @type {?} */
    NgProgressRef.prototype._config;
    /**
     * Stream that increments and updates progress state
     * @type {?}
     */
    NgProgressRef.prototype._trickling$;
    /**
     * Stream that emits when progress state is changed
     * @type {?}
     */
    NgProgressRef.prototype.state$;
    /**
     * Stream that emits when config is changed
     * @type {?}
     */
    NgProgressRef.prototype.config$;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3MtcmVmLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlLyIsInNvdXJjZXMiOlsibGliL25nLXByb2dyZXNzLXJlZi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBYyxPQUFPLEVBQUUsZUFBZSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RGLE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUUxRyxJQUFBO0lBcUNFLHVCQUFZLFlBQThCO1FBQTFDLGlCQVFDO3NCQTNDaUMsRUFBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUM7Ozs7MkJBSXJDLElBQUksT0FBTyxFQUFFOzs7O3NCQUcxQixJQUFJLGVBQWUsQ0FBa0IsSUFBSSxDQUFDLE1BQU0sQ0FBQzs7Ozt1QkFHaEQsSUFBSSxPQUFPLEVBQW9CO1FBMkJ2QyxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNoRCxRQUFRLENBQUMsVUFBQyxFQUE0QztnQkFBNUMsMEJBQTRDLEVBQTNDLGFBQUssRUFBRSxjQUFNO1lBQW1DLE9BQUEsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUE1QyxDQUE0QyxDQUFDLEVBQ3hHLFNBQVMsQ0FBQyxVQUFDLEVBQTRDO2dCQUE1QywwQkFBNEMsRUFBM0MsYUFBSyxFQUFFLGNBQU07WUFBbUMsT0FBQSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMs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QUFLLEVBQUMsQ0FBQyxFQUEvQixDQUErQixDQUFDOztRQUcxQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUNuQixHQUFHLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxTQUFTLENBQUMsRUFBQyxLQUFLLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBMUIsQ0FBMEIsQ0FBQyxDQUN0QyxDQUFDOzt3QkF6SE47SUEySEMsQ0FBQTtBQXZIRCx5QkF1SEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ1Byb2dyZXNzU3RhdGUsIE5nUHJvZ3Jlc3NDb25maWcgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIEJlaGF2aW9yU3ViamVjdCwgdGltZXIsIG9mLCBjb21iaW5lTGF0ZXN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRhcCwgbWFwLCBza2lwLCBkZWxheSwgZmlsdGVyLCBkZWJvdW5jZSwgc3dpdGNoTWFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzUmVmIHtcclxuXHJcbiAgcHJpdmF0ZSBfc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSA9IHthY3RpdmU6IGZhbHNlLCB2YWx1ZTogMH07XHJcbiAgcHJpdmF0ZSBfY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgaW5jcmVtZW50cyBhbmQgdXBkYXRlcyBwcm9ncmVzcyBzdGF0ZSAqL1xyXG4gIHByaXZhdGUgX3RyaWNrbGluZyQgPSBuZXcgU3ViamVjdCgpO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBwcm9ncmVzcyBzdGF0ZSBpcyBjaGFuZ2VkICovXHJcbiAgc3RhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzU3RhdGU+KHRoaXMuX3N0YXRlKTtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gY29uZmlnIGlzIGNoYW5nZWQgKi9cclxuICBjb25maWckID0gbmV3IFN1YmplY3Q8TmdQcm9ncmVzc0NvbmZpZz4oKTtcclxuXHJcbiAgZ2V0IGlzU3RhcnRlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5hY3RpdmU7XHJcbiAgfVxyXG5cclxuICAvKiogUHJvZ3Jlc3Mgc3RhcnQgZXZlbnQgKi9cclxuICBnZXQgc3RhcnRlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlJC5waXBlKFxyXG4gICAgICBtYXAoKHN0YXRlOiBOZ1Byb2dyZXNzU3RhdGUpID0+IHN0YXRlLmFjdGl2ZSksXHJcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgIGZpbHRlcihhY3RpdmUgPT4gYWN0aXZlKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKiBQcm9ncmVzcyBlbmRlZCBldmVudCAqL1xyXG4gIGdldCBjb21wbGV0ZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQucGlwZShcclxuICAgICAgbWFwKChzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSA9PiBzdGF0ZS5hY3RpdmUpLFxyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICBmaWx0ZXIoYWN0aXZlID0+ICFhY3RpdmUpLFxyXG4gICAgICBza2lwKDEpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoY3VzdG9tQ29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKSB7XHJcblxyXG4gICAgY29tYmluZUxhdGVzdCh0aGlzLl90cmlja2xpbmckLCB0aGlzLmNvbmZpZyQpLnBpcGUoXHJcbiAgICAgIGRlYm91bmNlKChbc3RhcnQsIGNvbmZpZ106IFtib29sZWFuLCBOZ1Byb2dyZXNzQ29uZmlnXSkgPT4gdGltZXIoc3RhcnQgPyB0aGlzLl9jb25maWcuZGVib3VuY2VUaW1lIDogMCkpLFxyXG4gICAgICBzd2l0Y2hNYXAoKFtzdGFydCwgY29uZmlnXTogW2Jvb2xlYW4sIE5nUHJvZ3Jlc3NDb25maWddKSA9PiBzdGFydCA/IHRoaXMuX3RyaWNrbGluZyhjb25maWcpIDogdGhpcy5fY29tcGxldGUoY29uZmlnKSlcclxuICAgICkuc3Vic2NyaWJlKCk7XHJcblxyXG4gICAgdGhpcy5zZXRDb25maWcoY3VzdG9tQ29uZmlnKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0KCkge1xyXG4gICAgdGhpcy5fdHJpY2tsaW5nJC5uZXh0KHRydWUpO1xyXG4gIH1cclxuXHJcbiAgY29tcGxldGUoKSB7XHJcbiAgICB0aGlzLl90cmlja2xpbmckLm5leHQoZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgaW5jKGFtb3VudD86IG51bWJlcikge1xyXG4gICAgY29uc3QgbiA9IHRoaXMuX3N0YXRlLnZhbHVlO1xyXG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xyXG4gICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodHlwZW9mIGFtb3VudCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICBhbW91bnQgPSB0aGlzLl9jb25maWcudHJpY2tsZUZ1bmMobik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZXQobiArIGFtb3VudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQobjogbnVtYmVyKSB7XHJcbiAgICB0aGlzLl9zZXRTdGF0ZSh7dmFsdWU6IHRoaXMuX2NsYW1wKG4pLCBhY3RpdmU6IHRydWV9KTtcclxuICB9XHJcblxyXG4gIHNldENvbmZpZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpIHtcclxuICAgIHRoaXMuX2NvbmZpZyA9IHsuLi50aGlzLl9jb25maWcsIC4uLmNvbmZpZ307XHJcbiAgICB0aGlzLmNvbmZpZyQubmV4dCh0aGlzLl9jb25maWcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWVhbnQgdG8gYmUgdXNlZCBpbnRlcm5hbGx5IGFuZCBub3QgYnkgdXNlciBkaXJlY3RseVxyXG4gICAqIFVzZXJzIHNob3VsZCB1c2UgTmdQcm9ncmVzc01hbmFnZXIuZGVzdHJveShpZCkgaW5zdGVhZFxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl90cmlja2xpbmckLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLnN0YXRlJC5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5jb25maWckLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zZXRTdGF0ZShzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSB7XHJcbiAgICB0aGlzLl9zdGF0ZSA9IHsuLi50aGlzLl9zdGF0ZSwgLi4uc3RhdGV9O1xyXG4gICAgdGhpcy5zdGF0ZSQubmV4dCh0aGlzLl9zdGF0ZSk7XHJcbiAgfVxyXG5cclxuICAvKiogQ2xhbXBzIGEgdmFsdWUgdG8gYmUgYmV0d2VlbiBtaW4gYW5kIG1heCAqL1xyXG4gIHByaXZhdGUgX2NsYW1wKG4pOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuX2NvbmZpZy5taW4sIE1hdGgubWluKHRoaXMuX2NvbmZpZy5tYXgsIG4pKTtcclxuICB9XHJcblxyXG4gIC8qKiBLZWVwcyBpbmNyZW1lbnRpbmcgdGhlIHByb2dyZXNzICovXHJcbiAgcHJpdmF0ZSBfdHJpY2tsaW5nKGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xyXG4gICAgICB0aGlzLnNldCh0aGlzLl9jb25maWcubWluKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aW1lcigwLCBjb25maWcudHJpY2tsZVNwZWVkKS5waXBlKHRhcCgoKSA9PiB0aGlzLmluYygpKSk7XHJcbiAgfVxyXG5cclxuICAvKiogQ29tcGxldGVzIHRoZW4gcmVzZXRzIHRoZSBwcm9ncmVzcyAqL1xyXG4gIHByaXZhdGUgX2NvbXBsZXRlKGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgcmV0dXJuICF0aGlzLmlzU3RhcnRlZCA/IG9mKHt9KSA6IG9mKHt9KS5waXBlKFxyXG4gICAgICAvLyBDb21wbGV0ZXMgdGhlIHByb2dyZXNzXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLl9zZXRTdGF0ZSh7dmFsdWU6IDEwMH0pKSxcclxuXHJcbiAgICAgIC8vIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIgYWZ0ZXIgYSB0aW55IGRlbGF5XHJcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCAqIDEuNyksXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLl9zZXRTdGF0ZSh7YWN0aXZlOiBmYWxzZX0pKSxcclxuXHJcbiAgICAgIC8vIFJlc2V0cyB0aGUgcHJvZ3Jlc3Mgc3RhdGVcclxuICAgICAgZGVsYXkoY29uZmlnLnNwZWVkKSxcclxuICAgICAgdGFwKCgpID0+IHRoaXMuX3NldFN0YXRlKHt2YWx1ZTogMH0pKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19