import { __assign, __read } from 'tslib';
import { Subject, BehaviorSubject, timer, of, combineLatest, EMPTY } from 'rxjs';
import { tap, map, skip, delay, filter, debounce, switchMap, distinctUntilChanged } from 'rxjs/operators';
import { InjectionToken, Injectable, Inject, Optional, Component, Input, Output, ChangeDetectionStrategy, EventEmitter, ViewEncapsulation, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NgProgressRef = /** @class */ (function () {
    function NgProgressRef(customConfig) {
        var _this = this;
        this._state = { active: false, value: 0 };
        /**
         * Stream that increments and updates progress state
         */
        this._trickling$ = new Subject();
        /**
         * Stream that emits when progress state is changed
         */
        this.state$ = new BehaviorSubject(this._state);
        /**
         * Stream that emits when config is changed
         */
        this.config$ = new Subject();
        combineLatest(this._trickling$, this.config$).pipe(debounce(function (_a) {
            var _b = __read(_a, 2), start = _b[0], config = _b[1];
            return timer(start ? _this._config.debounceTime : 0);
        }), switchMap(function (_a) {
            var _b = __read(_a, 2), start = _b[0], config = _b[1];
            return start ? _this._trickling(config) : _this._complete(config);
        })).subscribe();
        this.setConfig(customConfig);
    }
    Object.defineProperty(NgProgressRef.prototype, "isStarted", {
        get: /**
         * @return {?}
         */
        function () {
            return this._state.active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "started", {
        /** Progress start event */
        get: /**
         * Progress start event
         * @return {?}
         */
        function () {
            return this.state$.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return active; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "completed", {
        /** Progress ended event */
        get: /**
         * Progress ended event
         * @return {?}
         */
        function () {
            return this.state$.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return !active; }), skip(1));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgProgressRef.prototype.start = /**
     * @return {?}
     */
    function () {
        this._trickling$.next(true);
    };
    /**
     * @return {?}
     */
    NgProgressRef.prototype.complete = /**
     * @return {?}
     */
    function () {
        this._trickling$.next(false);
    };
    /**
     * @param {?=} amount
     * @return {?}
     */
    NgProgressRef.prototype.inc = /**
     * @param {?=} amount
     * @return {?}
     */
    function (amount) {
        var /** @type {?} */ n = this._state.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.trickleFunc(n);
            }
            this.set(n + amount);
        }
    };
    /**
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.set = /**
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this._setState({ value: this._clamp(n), active: true });
    };
    /**
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.setConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this._config = __assign({}, this._config, config);
        this.config$.next(this._config);
    };
    /**
     * Meant to be used internally and not by user directly
     * Users should use NgProgressManager.destroy(id) instead
     */
    /**
     * Meant to be used internally and not by user directly
     * Users should use NgProgressManager.destroy(id) instead
     * @return {?}
     */
    NgProgressRef.prototype.destroy = /**
     * Meant to be used internally and not by user directly
     * Users should use NgProgressManager.destroy(id) instead
     * @return {?}
     */
    function () {
        this._trickling$.complete();
        this.state$.complete();
        this.config$.complete();
    };
    /**
     * @param {?} state
     * @return {?}
     */
    NgProgressRef.prototype._setState = /**
     * @param {?} state
     * @return {?}
     */
    function (state) {
        this._state = __assign({}, this._state, state);
        this.state$.next(this._state);
    };
    /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype._clamp = /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    function (n) {
        return Math.max(this._config.min, Math.min(this._config.max, n));
    };
    /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype._trickling = /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        if (!this.isStarted) {
            this.set(this._config.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(function () { return _this.inc(); }));
    };
    /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype._complete = /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        return !this.isStarted ? of({}) : of({}).pipe(
        // Completes the progress
        tap(function () { return _this._setState({ value: 100 }); }), 
        // Hides the progress bar after a tiny delay
        delay(config.speed * 1.7), tap(function () { return _this._setState({ active: false }); }), 
        // Resets the progress state
        delay(config.speed), tap(function () { return _this._setState({ value: 0 }); }));
    };
    return NgProgressRef;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ CONFIG = new InjectionToken('config');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ɵ0 = function (n) {
    if (n >= 0 && n < 20)
        return 10;
    if (n >= 20 && n < 50)
        return 4;
    if (n >= 50 && n < 80)
        return 2;
    if (n >= 80 && n < 99)
        return 0.5;
    return 0;
};
var /** @type {?} */ defaultConfig = {
    meteor: true,
    spinner: true,
    thick: false,
    ease: 'linear',
    spinnerPosition: 'right',
    direction: 'ltr+',
    color: '#1B95E0',
    max: 100,
    min: 8,
    speed: 200,
    trickleSpeed: 300,
    debounceTime: 0,
    trickleFunc: ɵ0
};
var NgProgress = /** @class */ (function () {
    function NgProgress(config) {
        /**
         * Stores NgProgressRef instances
         */
        this._instances = {};
        this.config = __assign({}, defaultConfig, config);
    }
    /**
     * Returns NgProgressRef by ID
     */
    /**
     * Returns NgProgressRef by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    NgProgress.prototype.ref = /**
     * Returns NgProgressRef by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    function (id, config) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            return this._instances[id];
        }
        else {
            config = __assign({}, this.config, config);
            return this._instances[id] = new NgProgressRef(config);
        }
    };
    /**
     * @param {?} config
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.setConfig = /**
     * @param {?} config
     * @param {?=} id
     * @return {?}
     */
    function (config, id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].setConfig(config);
        }
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.start = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].start();
        }
    };
    /**
     * @param {?} n
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.set = /**
     * @param {?} n
     * @param {?=} id
     * @return {?}
     */
    function (n, id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].set(n);
        }
    };
    /**
     * @param {?=} n
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.inc = /**
     * @param {?=} n
     * @param {?=} id
     * @return {?}
     */
    function (n, id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].inc(n);
        }
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.complete = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].complete();
        }
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.isStarted = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (id === void 0) { id = 'root'; }
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].isStarted : false;
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.started = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (id === void 0) { id = 'root'; }
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].started : EMPTY;
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.completed = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (id === void 0) { id = 'root'; }
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].completed : EMPTY;
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.destroy = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].destroy();
            this._instances[id] = null;
        }
    };
    /**
     * @return {?}
     */
    NgProgress.prototype.destroyAll = /**
     * @return {?}
     */
    function () {
        var _this = this;
        Object.keys(this._instances).map(function (key) {
            _this._instances[key].destroy();
            _this._instances[key] = null;
        });
    };
    NgProgress.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NgProgress.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG,] },] },
    ]; };
    return NgProgress;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NgProgressComponent = /** @class */ (function () {
    function NgProgressComponent(_ngProgress) {
        this._ngProgress = _ngProgress;
        /**
         * Creates a new instance if id is not already exists
         */
        this.id = 'root';
        /**
         * Initializes inputs from the global config
         */
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.thick = this._ngProgress.config.thick;
        this.max = this._ngProgress.config.max;
        this.min = this._ngProgress.config.min;
        this.speed = this._ngProgress.config.speed;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when inputs change
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        }
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        this.state$ = this.progressRef.state$.pipe(map(function (state) {
            return ({
                active: state.active,
                transform: "translate3d(" + state.value + "%,0,0)"
            });
        }));
        /** Subscribes to started and completed events when user used them */
        if (this.started.observers.length) {
            this._started$ = this.progressRef.started.subscribe(function () { return _this.started.emit(); });
        }
        if (this.completed.observers.length) {
            this._completed$ = this.progressRef.completed.subscribe(function () { return _this.completed.emit(); });
        }
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._started$) {
            this._started$.unsubscribe();
        }
        if (this._completed$) {
            this._completed$.unsubscribe();
        }
        this._ngProgress.destroy(this.id);
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.start = /**
     * @return {?}
     */
    function () {
        this.progressRef.start();
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.complete = /**
     * @return {?}
     */
    function () {
        this.progressRef.complete();
    };
    /**
     * @param {?=} n
     * @return {?}
     */
    NgProgressComponent.prototype.inc = /**
     * @param {?=} n
     * @return {?}
     */
    function (n) {
        this.progressRef.inc(n);
    };
    /**
     * @param {?} n
     * @return {?}
     */
    NgProgressComponent.prototype.set = /**
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this.progressRef.set(n);
    };
    Object.defineProperty(NgProgressComponent.prototype, "isStarted", {
        get: /**
         * @return {?}
         */
        function () {
            return this.progressRef.isStarted;
        },
        enumerable: true,
        configurable: true
    });
    NgProgressComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ng-progress',
                    host: {
                        'role': 'progressbar',
                        '[attr.spinnerPosition]': 'spinnerPosition',
                        '[attr.dir]': 'direction',
                        '[attr.thick]': 'thick'
                    },
                    template: "\n    <ng-container *ngIf=\"state$ | async; let state\">\n      <div class=\"ng-progress-bar\"\n            [class.-active]=\"state.active\"\n            [style.transition]=\"'opacity ' + speed + 'ms ' + ease\">\n        <div class=\"ng-bar-placeholder\">\n          <div class=\"ng-bar\"\n                [style.transform]=\"state.transform\"\n                [style.backgroundColor]=\"color\"\n                [style.transition]=\"state.active ? 'all ' + speed + 'ms ' + ease : 'none'\">\n            <div *ngIf=\"meteor\" class=\"ng-meteor\" [style.boxShadow]=\"'0 0 10px '+ color + ', 0 0 5px ' + color\"></div>\n          </div>\n        </div>\n        <div *ngIf=\"spinner\" class=\"ng-spinner\">\n          <div class=\"ng-spinner-icon\"\n                [style.borderTopColor]=\"color\"\n                [style.borderLeftColor]=\"color\"></div>\n        </div>\n      </div>\n    </ng-container>\n  ",
                    styles: ["ng-progress{z-index:999999;pointer-events:none;position:relative}.ng-progress-bar{z-index:999999;top:0;left:0;width:100%;position:fixed;zoom:1;opacity:0}.ng-progress-bar.-active{opacity:1;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{display:block;position:fixed;z-index:1031;top:15px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:.4s linear infinite spinner-animation;animation:.4s linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}[dir='ltr+'] .ng-meteor,[dir=ltr-] .ng-meteor{-webkit-transform:rotate(3deg);transform:rotate(3deg)}[dir='ltr+'][thick=true] .ng-meteor,[dir=ltr-][thick=true] .ng-meteor{-webkit-transform:rotate(4deg);transform:rotate(4deg)}[dir='ltr+'] .ng-bar,[dir='rtl+'] .ng-bar{margin-left:-100%}[dir='ltr+'] .ng-meteor,[dir='rtl+'] .ng-meteor{right:0}[dir='ltr+'] .ng-meteor,[dir=rtl-] .ng-meteor{top:-3px}[dir='ltr+'][thick=true] .ng-meteor,[dir=rtl-][thick=true] .ng-meteor{top:-4px}[dir='rtl+'] .ng-meteor,[dir=ltr-] .ng-meteor{bottom:-3px}[dir='rtl+'][thick=true] .ng-meteor,[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}[dir='rtl+'] .ng-bar-placeholder,[dir=ltr-] .ng-bar-placeholder{-webkit-transform:rotate(180deg);transform:rotate(180deg)}[dir='rtl+'] .ng-spinner-icon,[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}[dir='rtl+'] .ng-meteor,[dir=rtl-] .ng-meteor{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}[dir='rtl+'][thick=true] .ng-meteor,[dir=rtl-][thick=true] .ng-meteor{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}[thick=true] .ng-bar-placeholder{height:3px}[spinnerPosition=left] .ng-spinner{left:15px;right:unset}[spinnerPosition=right] .ng-spinner{right:15px}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false
                },] },
    ];
    /** @nocollapse */
    NgProgressComponent.ctorParameters = function () { return [
        { type: NgProgress, },
    ]; };
    NgProgressComponent.propDecorators = {
        "id": [{ type: Input },],
        "spinnerPosition": [{ type: Input },],
        "direction": [{ type: Input },],
        "ease": [{ type: Input },],
        "color": [{ type: Input },],
        "meteor": [{ type: Input },],
        "spinner": [{ type: Input },],
        "thick": [{ type: Input },],
        "max": [{ type: Input },],
        "min": [{ type: Input },],
        "speed": [{ type: Input },],
        "trickleSpeed": [{ type: Input },],
        "trickleFunc": [{ type: Input },],
        "debounceTime": [{ type: Input },],
        "started": [{ type: Output },],
        "completed": [{ type: Output },],
    };
    return NgProgressComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} config
 * @return {?}
 */
function NgProgressFactory(config) {
    return new NgProgress(config);
}
var NgProgressModule = /** @class */ (function () {
    function NgProgressModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    NgProgressModule.forRoot = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: NgProgressModule,
            providers: [
                { provide: CONFIG, useValue: config },
                {
                    provide: NgProgress,
                    useFactory: NgProgressFactory,
                    deps: [CONFIG]
                }
            ]
        };
    };
    NgProgressModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [NgProgressComponent],
                    exports: [NgProgressComponent],
                    imports: [CommonModule]
                },] },
    ];
    return NgProgressModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { NgProgressFactory, NgProgressModule, NgProgressComponent, NgProgressRef, NgProgress, CONFIG as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXByb2dyZXNzYmFyLWNvcmUuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtcHJvZ3Jlc3NiYXIvY29yZS9saWIvbmctcHJvZ3Jlc3MtcmVmLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLnRva2VuLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLnNlcnZpY2UudHMiLCJuZzovL0BuZ3gtcHJvZ3Jlc3NiYXIvY29yZS9saWIvbmctcHJvZ3Jlc3MuY29tcG9uZW50LnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ1Byb2dyZXNzU3RhdGUsIE5nUHJvZ3Jlc3NDb25maWcgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIEJlaGF2aW9yU3ViamVjdCwgdGltZXIsIG9mLCBjb21iaW5lTGF0ZXN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRhcCwgbWFwLCBza2lwLCBkZWxheSwgZmlsdGVyLCBkZWJvdW5jZSwgc3dpdGNoTWFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzUmVmIHtcclxuXHJcbiAgcHJpdmF0ZSBfc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSA9IHthY3RpdmU6IGZhbHNlLCB2YWx1ZTogMH07XHJcbiAgcHJpdmF0ZSBfY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgaW5jcmVtZW50cyBhbmQgdXBkYXRlcyBwcm9ncmVzcyBzdGF0ZSAqL1xyXG4gIHByaXZhdGUgX3RyaWNrbGluZyQgPSBuZXcgU3ViamVjdCgpO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBwcm9ncmVzcyBzdGF0ZSBpcyBjaGFuZ2VkICovXHJcbiAgc3RhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzU3RhdGU+KHRoaXMuX3N0YXRlKTtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gY29uZmlnIGlzIGNoYW5nZWQgKi9cclxuICBjb25maWckID0gbmV3IFN1YmplY3Q8TmdQcm9ncmVzc0NvbmZpZz4oKTtcclxuXHJcbiAgZ2V0IGlzU3RhcnRlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5hY3RpdmU7XHJcbiAgfVxyXG5cclxuICAvKiogUHJvZ3Jlc3Mgc3RhcnQgZXZlbnQgKi9cclxuICBnZXQgc3RhcnRlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlJC5waXBlKFxyXG4gICAgICBtYXAoKHN0YXRlOiBOZ1Byb2dyZXNzU3RhdGUpID0+IHN0YXRlLmFjdGl2ZSksXHJcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgIGZpbHRlcihhY3RpdmUgPT4gYWN0aXZlKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKiBQcm9ncmVzcyBlbmRlZCBldmVudCAqL1xyXG4gIGdldCBjb21wbGV0ZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQucGlwZShcclxuICAgICAgbWFwKChzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSA9PiBzdGF0ZS5hY3RpdmUpLFxyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICBmaWx0ZXIoYWN0aXZlID0+ICFhY3RpdmUpLFxyXG4gICAgICBza2lwKDEpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoY3VzdG9tQ29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKSB7XHJcblxyXG4gICAgY29tYmluZUxhdGVzdCh0aGlzLl90cmlja2xpbmckLCB0aGlzLmNvbmZpZyQpLnBpcGUoXHJcbiAgICAgIGRlYm91bmNlKChbc3RhcnQsIGNvbmZpZ106IFtib29sZWFuLCBOZ1Byb2dyZXNzQ29uZmlnXSkgPT4gdGltZXIoc3RhcnQgPyB0aGlzLl9jb25maWcuZGVib3VuY2VUaW1lIDogMCkpLFxyXG4gICAgICBzd2l0Y2hNYXAoKFtzdGFydCwgY29uZmlnXTogW2Jvb2xlYW4sIE5nUHJvZ3Jlc3NDb25maWddKSA9PiBzdGFydCA/IHRoaXMuX3RyaWNrbGluZyhjb25maWcpIDogdGhpcy5fY29tcGxldGUoY29uZmlnKSlcclxuICAgICkuc3Vic2NyaWJlKCk7XHJcblxyXG4gICAgdGhpcy5zZXRDb25maWcoY3VzdG9tQ29uZmlnKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0KCkge1xyXG4gICAgdGhpcy5fdHJpY2tsaW5nJC5uZXh0KHRydWUpO1xyXG4gIH1cclxuXHJcbiAgY29tcGxldGUoKSB7XHJcbiAgICB0aGlzLl90cmlja2xpbmckLm5leHQoZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgaW5jKGFtb3VudD86IG51bWJlcikge1xyXG4gICAgY29uc3QgbiA9IHRoaXMuX3N0YXRlLnZhbHVlO1xyXG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xyXG4gICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodHlwZW9mIGFtb3VudCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICBhbW91bnQgPSB0aGlzLl9jb25maWcudHJpY2tsZUZ1bmMobik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZXQobiArIGFtb3VudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQobjogbnVtYmVyKSB7XHJcbiAgICB0aGlzLl9zZXRTdGF0ZSh7dmFsdWU6IHRoaXMuX2NsYW1wKG4pLCBhY3RpdmU6IHRydWV9KTtcclxuICB9XHJcblxyXG4gIHNldENvbmZpZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpIHtcclxuICAgIHRoaXMuX2NvbmZpZyA9IHsuLi50aGlzLl9jb25maWcsIC4uLmNvbmZpZ307XHJcbiAgICB0aGlzLmNvbmZpZyQubmV4dCh0aGlzLl9jb25maWcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWVhbnQgdG8gYmUgdXNlZCBpbnRlcm5hbGx5IGFuZCBub3QgYnkgdXNlciBkaXJlY3RseVxyXG4gICAqIFVzZXJzIHNob3VsZCB1c2UgTmdQcm9ncmVzc01hbmFnZXIuZGVzdHJveShpZCkgaW5zdGVhZFxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl90cmlja2xpbmckLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLnN0YXRlJC5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5jb25maWckLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zZXRTdGF0ZShzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSB7XHJcbiAgICB0aGlzLl9zdGF0ZSA9IHsuLi50aGlzLl9zdGF0ZSwgLi4uc3RhdGV9O1xyXG4gICAgdGhpcy5zdGF0ZSQubmV4dCh0aGlzLl9zdGF0ZSk7XHJcbiAgfVxyXG5cclxuICAvKiogQ2xhbXBzIGEgdmFsdWUgdG8gYmUgYmV0d2VlbiBtaW4gYW5kIG1heCAqL1xyXG4gIHByaXZhdGUgX2NsYW1wKG4pOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuX2NvbmZpZy5taW4sIE1hdGgubWluKHRoaXMuX2NvbmZpZy5tYXgsIG4pKTtcclxuICB9XHJcblxyXG4gIC8qKiBLZWVwcyBpbmNyZW1lbnRpbmcgdGhlIHByb2dyZXNzICovXHJcbiAgcHJpdmF0ZSBfdHJpY2tsaW5nKGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xyXG4gICAgICB0aGlzLnNldCh0aGlzLl9jb25maWcubWluKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aW1lcigwLCBjb25maWcudHJpY2tsZVNwZWVkKS5waXBlKHRhcCgoKSA9PiB0aGlzLmluYygpKSk7XHJcbiAgfVxyXG5cclxuICAvKiogQ29tcGxldGVzIHRoZW4gcmVzZXRzIHRoZSBwcm9ncmVzcyAqL1xyXG4gIHByaXZhdGUgX2NvbXBsZXRlKGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgcmV0dXJuICF0aGlzLmlzU3RhcnRlZCA/IG9mKHt9KSA6IG9mKHt9KS5waXBlKFxyXG4gICAgICAvLyBDb21wbGV0ZXMgdGhlIHByb2dyZXNzXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLl9zZXRTdGF0ZSh7dmFsdWU6IDEwMH0pKSxcclxuXHJcbiAgICAgIC8vIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIgYWZ0ZXIgYSB0aW55IGRlbGF5XHJcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCAqIDEuNyksXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLl9zZXRTdGF0ZSh7YWN0aXZlOiBmYWxzZX0pKSxcclxuXHJcbiAgICAgIC8vIFJlc2V0cyB0aGUgcHJvZ3Jlc3Mgc3RhdGVcclxuICAgICAgZGVsYXkoY29uZmlnLnNwZWVkKSxcclxuICAgICAgdGFwKCgpID0+IHRoaXMuX3NldFN0YXRlKHt2YWx1ZTogMH0pKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc0NvbmZpZyB9IGZyb20gJy4vbmctcHJvZ3Jlc3MuaW50ZXJmYWNlJztcclxuXHJcbmV4cG9ydCBjb25zdCBDT05GSUcgPSBuZXcgSW5qZWN0aW9uVG9rZW48TmdQcm9ncmVzc0NvbmZpZz4oJ2NvbmZpZycpO1xyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NSZWYgfSBmcm9tICcuL25nLXByb2dyZXNzLXJlZic7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NDb25maWcgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IEVNUFRZIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IENPTkZJRyB9IGZyb20gJy4vbmctcHJvZ3Jlc3MudG9rZW4nO1xyXG5cclxuY29uc3QgZGVmYXVsdENvbmZpZzogTmdQcm9ncmVzc0NvbmZpZyA9IHtcclxuICBtZXRlb3I6IHRydWUsXHJcbiAgc3Bpbm5lcjogdHJ1ZSxcclxuICB0aGljazogZmFsc2UsXHJcbiAgZWFzZTogJ2xpbmVhcicsXHJcbiAgc3Bpbm5lclBvc2l0aW9uOiAncmlnaHQnLFxyXG4gIGRpcmVjdGlvbjogJ2x0cisnLFxyXG4gIGNvbG9yOiAnIzFCOTVFMCcsXHJcbiAgbWF4OiAxMDAsXHJcbiAgbWluOiA4LFxyXG4gIHNwZWVkOiAyMDAsXHJcbiAgdHJpY2tsZVNwZWVkOiAzMDAsXHJcbiAgZGVib3VuY2VUaW1lOiAwLFxyXG4gIHRyaWNrbGVGdW5jOiAobjogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgIGlmIChuID49IDAgJiYgbiA8IDIwKSByZXR1cm4gMTA7XHJcbiAgICBpZiAobiA+PSAyMCAmJiBuIDwgNTApIHJldHVybiA0O1xyXG4gICAgaWYgKG4gPj0gNTAgJiYgbiA8IDgwKSByZXR1cm4gMjtcclxuICAgIGlmIChuID49IDgwICYmIG4gPCA5OSkgcmV0dXJuIDAuNTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3Mge1xyXG5cclxuICAvKiogU3RvcmVzIE5nUHJvZ3Jlc3NSZWYgaW5zdGFuY2VzICovXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfaW5zdGFuY2VzID0ge307XHJcblxyXG4gIC8qKiBHbG9iYWwgY29uZmlnICovXHJcbiAgY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnO1xyXG5cclxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KENPTkZJRykgY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKSB7XHJcbiAgICB0aGlzLmNvbmZpZyA9IHsuLi5kZWZhdWx0Q29uZmlnLCAuLi5jb25maWd9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBOZ1Byb2dyZXNzUmVmIGJ5IElEXHJcbiAgICovXHJcbiAgcmVmKGlkID0gJ3Jvb3QnLCBjb25maWc/OiBOZ1Byb2dyZXNzQ29uZmlnKSB7XHJcbiAgICBpZiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlc1tpZF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25maWcgPSB7Li4udGhpcy5jb25maWcsIC4uLmNvbmZpZ307XHJcbiAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZXNbaWRdID0gbmV3IE5nUHJvZ3Jlc3NSZWYoY29uZmlnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldENvbmZpZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcsIGlkID0gJ3Jvb3QnKSB7XHJcbiAgICBpZiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpIHtcclxuICAgICAgdGhpcy5faW5zdGFuY2VzW2lkXS5zZXRDb25maWcoY29uZmlnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXJ0KGlkID0gJ3Jvb3QnKSB7XHJcbiAgICBpZiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpIHtcclxuICAgICAgdGhpcy5faW5zdGFuY2VzW2lkXS5zdGFydCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0KG46IG51bWJlciwgaWQgPSAncm9vdCcpIHtcclxuICAgIGlmICh0aGlzLl9pbnN0YW5jZXNbaWRdIGluc3RhbmNlb2YgTmdQcm9ncmVzc1JlZikge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXNbaWRdLnNldChuKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGluYyhuPzogbnVtYmVyLCBpZCA9ICdyb290Jykge1xyXG4gICAgaWYgKHRoaXMuX2luc3RhbmNlc1tpZF0gaW5zdGFuY2VvZiBOZ1Byb2dyZXNzUmVmKSB7XHJcbiAgICAgIHRoaXMuX2luc3RhbmNlc1tpZF0uaW5jKG4pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29tcGxldGUoaWQgPSAncm9vdCcpIHtcclxuICAgIGlmICh0aGlzLl9pbnN0YW5jZXNbaWRdIGluc3RhbmNlb2YgTmdQcm9ncmVzc1JlZikge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXNbaWRdLmNvbXBsZXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpc1N0YXJ0ZWQoaWQgPSAncm9vdCcpIHtcclxuICAgIHJldHVybiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpID8gdGhpcy5faW5zdGFuY2VzW2lkXS5pc1N0YXJ0ZWQgOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHN0YXJ0ZWQoaWQgPSAncm9vdCcpIHtcclxuICAgIHJldHVybiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpID8gdGhpcy5faW5zdGFuY2VzW2lkXS5zdGFydGVkIDogRU1QVFk7XHJcbiAgfVxyXG5cclxuICBjb21wbGV0ZWQoaWQgPSAncm9vdCcpIHtcclxuICAgIHJldHVybiAodGhpcy5faW5zdGFuY2VzW2lkXSBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpID8gdGhpcy5faW5zdGFuY2VzW2lkXS5jb21wbGV0ZWQgOiBFTVBUWTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koaWQgPSAncm9vdCcpIHtcclxuICAgIGlmICh0aGlzLl9pbnN0YW5jZXNbaWRdIGluc3RhbmNlb2YgTmdQcm9ncmVzc1JlZikge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXNbaWRdLmRlc3Ryb3koKTtcclxuICAgICAgdGhpcy5faW5zdGFuY2VzW2lkXSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZXN0cm95QWxsKCkge1xyXG4gICAgT2JqZWN0LmtleXModGhpcy5faW5zdGFuY2VzKS5tYXAoKGtleSkgPT4ge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXNba2V5XS5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMuX2luc3RhbmNlc1trZXldID0gbnVsbDtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IG5neC1wcm9ncmVzc2JhciBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9NdXJoYWZTb3VzbGkvbmd4LXByb2dyZXNzYmFyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBJbnB1dCxcclxuICBPbkNoYW5nZXMsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9uSW5pdCxcclxuICBPdXRwdXQsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIFZpZXdFbmNhcHN1bGF0aW9uXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3MgfSBmcm9tICcuL25nLXByb2dyZXNzLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzUmVmIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy1yZWYnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzU3RhdGUgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnbmctcHJvZ3Jlc3MnLFxyXG4gIGhvc3Q6IHtcclxuICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcclxuICAgICdbYXR0ci5zcGlubmVyUG9zaXRpb25dJzogJ3NwaW5uZXJQb3NpdGlvbicsXHJcbiAgICAnW2F0dHIuZGlyXSc6ICdkaXJlY3Rpb24nLFxyXG4gICAgJ1thdHRyLnRoaWNrXSc6ICd0aGljaydcclxuICB9LFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic3RhdGUkIHwgYXN5bmM7IGxldCBzdGF0ZVwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwibmctcHJvZ3Jlc3MtYmFyXCJcclxuICAgICAgICAgICAgW2NsYXNzLi1hY3RpdmVdPVwic3RhdGUuYWN0aXZlXCJcclxuICAgICAgICAgICAgW3N0eWxlLnRyYW5zaXRpb25dPVwiJ29wYWNpdHkgJyArIHNwZWVkICsgJ21zICcgKyBlYXNlXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm5nLWJhci1wbGFjZWhvbGRlclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5nLWJhclwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUudHJhbnNmb3JtXT1cInN0YXRlLnRyYW5zZm9ybVwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cImNvbG9yXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cInN0YXRlLmFjdGl2ZSA/ICdhbGwgJyArIHNwZWVkICsgJ21zICcgKyBlYXNlIDogJ25vbmUnXCI+XHJcbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJtZXRlb3JcIiBjbGFzcz1cIm5nLW1ldGVvclwiIFtzdHlsZS5ib3hTaGFkb3ddPVwiJzAgMCAxMHB4ICcrIGNvbG9yICsgJywgMCAwIDVweCAnICsgY29sb3JcIj48L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgKm5nSWY9XCJzcGlubmVyXCIgY2xhc3M9XCJuZy1zcGlubmVyXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmctc3Bpbm5lci1pY29uXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS5ib3JkZXJUb3BDb2xvcl09XCJjb2xvclwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYm9yZGVyTGVmdENvbG9yXT1cImNvbG9yXCI+PC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcbiAgYCxcclxuICBzdHlsZXM6IFtgbmctcHJvZ3Jlc3N7ei1pbmRleDo5OTk5OTk7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjpyZWxhdGl2ZX0ubmctcHJvZ3Jlc3MtYmFye3otaW5kZXg6OTk5OTk5O3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO3Bvc2l0aW9uOmZpeGVkO3pvb206MTtvcGFjaXR5OjB9Lm5nLXByb2dyZXNzLWJhci4tYWN0aXZle29wYWNpdHk6MTt0cmFuc2l0aW9uOm5vbmV9Lm5nLWJhci1wbGFjZWhvbGRlcntwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MnB4O3dpZHRoOjEwMCV9Lm5nLWJhcnt3aWR0aDoxMDAlO2hlaWdodDoxMDAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSgtMTAwJSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTEwMCUsMCwwKX0ubmctbWV0ZW9ye2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwcHg7aGVpZ2h0OjEwMCU7b3BhY2l0eToxfS5uZy1zcGlubmVye2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoxMDMxO3RvcDoxNXB4fS5uZy1zcGlubmVyLWljb257d2lkdGg6MThweDtoZWlnaHQ6MThweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1hbmltYXRpb246LjRzIGxpbmVhciBpbmZpbml0ZSBzcGlubmVyLWFuaW1hdGlvbjthbmltYXRpb246LjRzIGxpbmVhciBpbmZpbml0ZSBzcGlubmVyLWFuaW1hdGlvbjtib3JkZXI6MnB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6NTAlfVtkaXI9J2x0cisnXSAubmctbWV0ZW9yLFtkaXI9bHRyLV0gLm5nLW1ldGVvcnstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoM2RlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzZGVnKX1bZGlyPSdsdHIrJ11bdGhpY2s9dHJ1ZV0gLm5nLW1ldGVvcixbZGlyPWx0ci1dW3RoaWNrPXRydWVdIC5uZy1tZXRlb3J7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDRkZWcpO3RyYW5zZm9ybTpyb3RhdGUoNGRlZyl9W2Rpcj0nbHRyKyddIC5uZy1iYXIsW2Rpcj0ncnRsKyddIC5uZy1iYXJ7bWFyZ2luLWxlZnQ6LTEwMCV9W2Rpcj0nbHRyKyddIC5uZy1tZXRlb3IsW2Rpcj0ncnRsKyddIC5uZy1tZXRlb3J7cmlnaHQ6MH1bZGlyPSdsdHIrJ10gLm5nLW1ldGVvcixbZGlyPXJ0bC1dIC5uZy1tZXRlb3J7dG9wOi0zcHh9W2Rpcj0nbHRyKyddW3RoaWNrPXRydWVdIC5uZy1tZXRlb3IsW2Rpcj1ydGwtXVt0aGljaz10cnVlXSAubmctbWV0ZW9ye3RvcDotNHB4fVtkaXI9J3J0bCsnXSAubmctbWV0ZW9yLFtkaXI9bHRyLV0gLm5nLW1ldGVvcntib3R0b206LTNweH1bZGlyPSdydGwrJ11bdGhpY2s9dHJ1ZV0gLm5nLW1ldGVvcixbZGlyPWx0ci1dW3RoaWNrPXRydWVdIC5uZy1tZXRlb3J7Ym90dG9tOi00cHh9W2Rpcj0ncnRsKyddIC5uZy1iYXItcGxhY2Vob2xkZXIsW2Rpcj1sdHItXSAubmctYmFyLXBsYWNlaG9sZGVyey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX1bZGlyPSdydGwrJ10gLm5nLXNwaW5uZXItaWNvbixbZGlyPWx0ci1dIC5uZy1zcGlubmVyLWljb257YW5pbWF0aW9uLWRpcmVjdGlvbjpyZXZlcnNlfVtkaXI9J3J0bCsnXSAubmctbWV0ZW9yLFtkaXI9cnRsLV0gLm5nLW1ldGVvcnstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoLTNkZWcpO3RyYW5zZm9ybTpyb3RhdGUoLTNkZWcpfVtkaXI9J3J0bCsnXVt0aGljaz10cnVlXSAubmctbWV0ZW9yLFtkaXI9cnRsLV1bdGhpY2s9dHJ1ZV0gLm5nLW1ldGVvcnstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoLTRkZWcpO3RyYW5zZm9ybTpyb3RhdGUoLTRkZWcpfVt0aGljaz10cnVlXSAubmctc3Bpbm5lci1pY29ue3dpZHRoOjI0cHg7aGVpZ2h0OjI0cHg7Ym9yZGVyLXdpZHRoOjNweH1bdGhpY2s9dHJ1ZV0gLm5nLWJhci1wbGFjZWhvbGRlcntoZWlnaHQ6M3B4fVtzcGlubmVyUG9zaXRpb249bGVmdF0gLm5nLXNwaW5uZXJ7bGVmdDoxNXB4O3JpZ2h0OnVuc2V0fVtzcGlubmVyUG9zaXRpb249cmlnaHRdIC5uZy1zcGlubmVye3JpZ2h0OjE1cHh9QC13ZWJraXQta2V5ZnJhbWVzIHNwaW5uZXItYW5pbWF0aW9uezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwKTt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIHNwaW5uZXItYW5pbWF0aW9uezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwKTt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1gXSxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xyXG5cclxuICBwcml2YXRlIF9zdGFydGVkJDogU3Vic2NyaXB0aW9uO1xyXG4gIHByaXZhdGUgX2NvbXBsZXRlZCQ6IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgLyoqIFByb2dyZXNzIGJhciB3b3JrZXIgKi9cclxuICBwcm9ncmVzc1JlZjogTmdQcm9ncmVzc1JlZjtcclxuXHJcbiAgLyoqIFByb2dyZXNzIHN0YXRlIHN0cmVhbSAqL1xyXG4gIHN0YXRlJDogT2JzZXJ2YWJsZTx7IGFjdGl2ZTogYm9vbGVhbiwgdHJhbnNmb3JtOiBzdHJpbmcgfT47XHJcblxyXG4gIC8qKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGlmIGlkIGlzIG5vdCBhbHJlYWR5IGV4aXN0cyAqL1xyXG4gIEBJbnB1dCgpIGlkID0gJ3Jvb3QnO1xyXG5cclxuICAvKiogSW5pdGlhbGl6ZXMgaW5wdXRzIGZyb20gdGhlIGdsb2JhbCBjb25maWcgKi9cclxuICBASW5wdXQoKSBzcGlubmVyUG9zaXRpb246ICdsZWZ0JyB8ICdyaWdodCcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5zcGlubmVyUG9zaXRpb247XHJcbiAgQElucHV0KCkgZGlyZWN0aW9uOiAnbHRyKycgfCAnbHRyLScgfCAncnRsKycgfCAncnRsLScgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5kaXJlY3Rpb247XHJcbiAgQElucHV0KCkgZWFzZTogc3RyaW5nID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuZWFzZTtcclxuICBASW5wdXQoKSBjb2xvcjogc3RyaW5nID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuY29sb3I7XHJcbiAgQElucHV0KCkgbWV0ZW9yOiBib29sZWFuID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcubWV0ZW9yO1xyXG4gIEBJbnB1dCgpIHNwaW5uZXI6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5zcGlubmVyO1xyXG4gIEBJbnB1dCgpIHRoaWNrOiBib29sZWFuID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcudGhpY2s7XHJcbiAgQElucHV0KCkgbWF4OiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5tYXg7XHJcbiAgQElucHV0KCkgbWluOiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5taW47XHJcbiAgQElucHV0KCkgc3BlZWQ6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnNwZWVkO1xyXG4gIEBJbnB1dCgpIHRyaWNrbGVTcGVlZDogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcudHJpY2tsZVNwZWVkO1xyXG4gIEBJbnB1dCgpIHRyaWNrbGVGdW5jOiAobjogbnVtYmVyKSA9PiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50cmlja2xlRnVuYztcclxuICBASW5wdXQoKSBkZWJvdW5jZVRpbWU6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmRlYm91bmNlVGltZTtcclxuICBAT3V0cHV0KCkgc3RhcnRlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICBAT3V0cHV0KCkgY29tcGxldGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9uZ1Byb2dyZXNzOiBOZ1Byb2dyZXNzKSB7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcygpIHtcclxuICAgIGlmICh0aGlzLnByb2dyZXNzUmVmIGluc3RhbmNlb2YgTmdQcm9ncmVzc1JlZikge1xyXG4gICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3MgYmFyIGNvbmZpZyB3aGVuIGlucHV0cyBjaGFuZ2VcclxuICAgICAgdGhpcy5wcm9ncmVzc1JlZi5zZXRDb25maWcoe1xyXG4gICAgICAgIG1heDogKHRoaXMubWF4ID4gMCAmJiB0aGlzLm1heCA8PSAxMDApID8gdGhpcy5tYXggOiAxMDAsXHJcbiAgICAgICAgbWluOiAodGhpcy5taW4gPCAxMDAgJiYgdGhpcy5taW4gPj0gMCkgPyB0aGlzLm1pbiA6IDAsXHJcbiAgICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXHJcbiAgICAgICAgdHJpY2tsZVNwZWVkOiB0aGlzLnRyaWNrbGVTcGVlZCxcclxuICAgICAgICB0cmlja2xlRnVuYzogdGhpcy50cmlja2xlRnVuYyxcclxuICAgICAgICBkZWJvdW5jZVRpbWU6IHRoaXMuZGVib3VuY2VUaW1lXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICAvLyBHZXQgcHJvZ3Jlc3MgYmFyIHNlcnZpY2UgaW5zdGFuY2VcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYgPSB0aGlzLl9uZ1Byb2dyZXNzLnJlZih0aGlzLmlkLCB7XHJcbiAgICAgIG1heDogdGhpcy5tYXgsXHJcbiAgICAgIG1pbjogdGhpcy5taW4sXHJcbiAgICAgIHNwZWVkOiB0aGlzLnNwZWVkLFxyXG4gICAgICB0cmlja2xlU3BlZWQ6IHRoaXMudHJpY2tsZVNwZWVkLFxyXG4gICAgICBkZWJvdW5jZVRpbWU6IHRoaXMuZGVib3VuY2VUaW1lXHJcbiAgICB9KTtcclxuICAgIHRoaXMuc3RhdGUkID0gdGhpcy5wcm9ncmVzc1JlZi5zdGF0ZSQucGlwZShtYXAoKHN0YXRlOiBOZ1Byb2dyZXNzU3RhdGUpID0+ICh7XHJcbiAgICAgIGFjdGl2ZTogc3RhdGUuYWN0aXZlLFxyXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3N0YXRlLnZhbHVlfSUsMCwwKWBcclxuICAgIH0pKSk7XHJcbiAgICAvKiogU3Vic2NyaWJlcyB0byBzdGFydGVkIGFuZCBjb21wbGV0ZWQgZXZlbnRzIHdoZW4gdXNlciB1c2VkIHRoZW0gKi9cclxuICAgIGlmICh0aGlzLnN0YXJ0ZWQub2JzZXJ2ZXJzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9zdGFydGVkJCA9IHRoaXMucHJvZ3Jlc3NSZWYuc3RhcnRlZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zdGFydGVkLmVtaXQoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jb21wbGV0ZWQub2JzZXJ2ZXJzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9jb21wbGV0ZWQkID0gdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZWQuc3Vic2NyaWJlKCgpID0+IHRoaXMuY29tcGxldGVkLmVtaXQoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLl9zdGFydGVkJCkge1xyXG4gICAgICB0aGlzLl9zdGFydGVkJC51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2NvbXBsZXRlZCQpIHtcclxuICAgICAgdGhpcy5fY29tcGxldGVkJC51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbmdQcm9ncmVzcy5kZXN0cm95KHRoaXMuaWQpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnQoKSB7XHJcbiAgICB0aGlzLnByb2dyZXNzUmVmLnN0YXJ0KCk7XHJcbiAgfVxyXG5cclxuICBjb21wbGV0ZSgpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuY29tcGxldGUoKTtcclxuICB9XHJcblxyXG4gIGluYyhuPzogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnByb2dyZXNzUmVmLmluYyhuKTtcclxuICB9XHJcblxyXG4gIHNldChuOiBudW1iZXIpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuc2V0KG4pO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGlzU3RhcnRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnByb2dyZXNzUmVmLmlzU3RhcnRlZDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc0NvbXBvbmVudCB9IGZyb20gJy4vbmctcHJvZ3Jlc3MuY29tcG9uZW50JztcclxuaW1wb3J0IHsgTmdQcm9ncmVzcyB9IGZyb20gJy4vbmctcHJvZ3Jlc3Muc2VydmljZSc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NDb25maWcgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IENPTkZJRyB9IGZyb20gJy4vbmctcHJvZ3Jlc3MudG9rZW4nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIE5nUHJvZ3Jlc3NGYWN0b3J5KGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gIHJldHVybiBuZXcgTmdQcm9ncmVzcyhjb25maWcpO1xyXG59XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGRlY2xhcmF0aW9uczogW05nUHJvZ3Jlc3NDb21wb25lbnRdLFxyXG4gIGV4cG9ydHM6IFtOZ1Byb2dyZXNzQ29tcG9uZW50XSxcclxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc01vZHVsZSB7XHJcbiAgc3RhdGljIGZvclJvb3QoY29uZmlnPzogTmdQcm9ncmVzc0NvbmZpZyk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5nUHJvZ3Jlc3NNb2R1bGUsXHJcbiAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIHtwcm92aWRlOiBDT05GSUcsIHVzZVZhbHVlOiBjb25maWd9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IE5nUHJvZ3Jlc3MsXHJcbiAgICAgICAgICB1c2VGYWN0b3J5OiBOZ1Byb2dyZXNzRmFjdG9yeSxcclxuICAgICAgICAgIGRlcHM6IFtDT05GSUddXHJcbiAg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